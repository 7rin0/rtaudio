 

\begin{center}
 {\bf Introduction} {\rm (p.\,\pageref{intro})} \ \  {\bf Download} {\rm (p.\,\pageref{download})} \ \  {\bf Getting Started} {\rm (p.\,\pageref{start})} \ \  {\bf Error Handling} {\rm (p.\,\pageref{error})} \ \  {\bf Probing Device Capabilities} {\rm (p.\,\pageref{probing})} \ \  {\bf Device Settings} {\rm (p.\,\pageref{settings})} \ \  {\bf Playback (blocking functionality)} {\rm (p.\,\pageref{playbackb})} \ \  {\bf Playback (callback functionality)} {\rm (p.\,\pageref{playbackc})} \ \  {\bf Recording} {\rm (p.\,\pageref{recording})} \ \  {\bf Duplex Mode} {\rm (p.\,\pageref{duplex})} \ \  {\bf Summary of Methods} {\rm (p.\,\pageref{methods})} \ \  {\bf Compiling} {\rm (p.\,\pageref{compiling})} \ \  {\bf OS Notes} {\rm (p.\,\pageref{osnotes})} \ \  {\bf Acknowledgments} {\rm (p.\,\pageref{acknowledge})} \end{center}


\section{Introduction}\label{intro}


{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} is a C++ class which provides a common API (Application Programming Interface) for realtime audio input/output across Linux (native ALSA and OSS), SGI, and Windows operating systems. {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} significantly simplifies the process of interacting with computer audio hardware. It was designed with the following goals:

\begin{CompactItemize}
 \item 
object oriented C++ design \item 
simple, common API across all supported platforms \item 
single independent header and source file for easy inclusion in programming projects (no libraries!) \item 
blocking functionality \item 
callback functionality \item 
extensive audio device parameter control \item 
audio device capability probing \item 
automatic internal conversion for data format, channel number compensation, de-interleaving, and byte-swapping \item 
control over multiple audio streams and devices with a single instance \end{CompactItemize}


{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} incorporates the concept of audio streams, which represent audio output (playback) and/or input (recording). Available audio devices and their capabilities can be enumerated and then specified when opening a stream. Multiple streams can run at the same time and, when allowed by the underlying audio API, a single device can serve multiple streams.

The {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} API provides both blocking (synchronous) and callback (asynchronous) functionality. Callbacks are typically used in conjunction with graphical user interfaces (GUI). Blocking functionality is often necessary for explicit control of multiple input/output stream synchronization or when audio must be synchronized with other system events.

\section{Download}\label{download}


Latest Release (22 January 2002): {\tt Version 2.0 (111 k\-B tar/gzipped)}

\section{Getting Started}\label{start}


The first thing that must be done when using {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} is to create an instance of the class. The default constructor {\bf Rt\-Audio::Rt\-Audio}() {\rm (p.\,\pageref{classRtAudio_a0})} scans the underlying audio system to verify that at least one device is available. {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} often uses C++ exceptions to report errors, necessitating try/catch blocks around most member functions. The following code example demonstrates default object construction and destruction:

\footnotesize\begin{verbatim}#include "RtAudio.h"

int main()
{
  RtAudio *audio;

  // Default RtAudio constructor
  try {
    audio = new RtAudio();
  }
  catch (RtAudioError &error) {
    // Handle the exception here
  }

  // Clean up
  delete audio;
}\end{verbatim}\normalsize 


Obviously, this example doesn't demonstrate any of the real functionality of {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})}. However, all uses of {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} must begin with a constructor (either default or overloaded varieties) and must end with class destruction. Further, it is necessary that all class methods which can throw a C++ exception be called within a try/catch block.

\section{Error Handling}\label{error}


{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} uses a C++ exception handler called {\bf Rt\-Audio\-Error} {\rm (p.\,\pageref{classRtAudioError})}, which is declared and defined within the {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} class files. The {\bf Rt\-Audio\-Error} {\rm (p.\,\pageref{classRtAudioError})} class is quite simple but it does allow errors to be \char`\"{}caught\char`\"{} by {\bf Rt\-Audio\-Error::TYPE} {\rm (p.\,\pageref{classRtAudioError_s11})}. Almost all {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} methods can \char`\"{}throw\char`\"{} an {\bf Rt\-Audio\-Error} {\rm (p.\,\pageref{classRtAudioError})}, most typically if an invalid stream identifier is supplied to a method or a driver error occurs. There are a number of cases within {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} where warning messages may be displayed but an exception is not thrown. There is a private {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} method, error(), which can be modified to globally control how these messages are handled and reported.

\section{Probing Device Capabilities}\label{probing}


A programmer may wish to query the available audio device capabilities before deciding which to use. The following example outlines how this can be done.

\footnotesize\begin{verbatim}// probe.cpp

#include <iostream.h>
#include "RtAudio.h"

int main()
{
  RtAudio *audio;

  // Default RtAudio constructor
  try {
    audio = new RtAudio();
  }
  catch (RtAudioError &error) {
    error.printMessage();
    exit(EXIT_FAILURE);
  }

  // Determine the number of devices available
  int devices = audio->getDeviceCount();

  // Scan through devices for various capabilities
  RtAudio::RTAUDIO_DEVICE info;
  for (int i=0; i<devices; i++) {

    try {
      audio->getDeviceInfo(i, &info);
    }
    catch (RtAudioError &error) {
      error.printMessage();
      break;
    }

    // Print, for example, the maximum number of output channels for each device
    cout << "device = " << i;
    cout << ": maximum output channels = " << info.maxOutputChannels << endl;
  }

  // Clean up
  delete audio;

  return 0;
}\end{verbatim}\normalsize 


The RTAUDIO\_\-DEVICE structure is defined in {\bf Rt\-Audio.h} and provides a variety of information useful in assessing the capabilities of a device:

\footnotesize\begin{verbatim}  typedef struct {
    char name[128];
    DEVICE_ID id[2];                      // No value reported by getDeviceInfo().
    bool probed;                          // true if the device probe was successful.
    int maxOutputChannels;
    int maxInputChannels;
    int maxDuplexChannels;
    int minOutputChannels;
    int minInputChannels;
    int minDuplexChannels;
    bool hasDuplexSupport;                // true if duplex supported
    int nSampleRates;                     // Number of discrete rates, or -1 if range supported.
    double sampleRates[MAX_SAMPLE_RATES]; // Supported sample rates, or {min, max} if range.
    RTAUDIO_FORMAT nativeFormats;
  } RTAUDIO_DEVICE;\end{verbatim}\normalsize 


The following data formats are defined and fully supported by {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})}:

\footnotesize\begin{verbatim}  typedef unsigned long RTAUDIO_FORMAT;
  static const RTAUDIO_FORMAT  RTAUDIO_SINT8;   // Signed 8-bit integer
  static const RTAUDIO_FORMAT  RTAUDIO_SINT16;  // Signed 16-bit integer
  static const RTAUDIO_FORMAT  RTAUDIO_SINT24;  // Signed 24-bit integer
  static const RTAUDIO_FORMAT  RTAUDIO_SINT32;  // Signed 32-bit integer
  static const RTAUDIO_FORMAT  RTAUDIO_FLOAT32; // 32-bit float
  static const RTAUDIO_FORMAT  RTAUDIO_FLOAT64; // 64-bit double\end{verbatim}\normalsize 


The {\em native\-Formats} member of the {\bf Rt\-Audio::RTAUDIO\_\-DEVICE} {\rm (p.\,\pageref{structRtAudio_1_1RTAUDIO__DEVICE})} structure is a bit mask of the above formats which are natively supported by the device. However, {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} will automatically provide format conversion if a particular format is not natively supported. When the {\em probed} member of the RTAUDIO\_\-DEVICE structure is false, the remaining structure members are likely unknown and the device is probably unusable.

In general, the user need not be concerned with the minimum channel values reported in the RTAUDIO\_\-DEVICE structure. While some audio devices may require a minimum channel value $>$ 1, {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} will provide automatic channel number compensation when the number of channels set by the user is less than that required by the device. Channel compensation is {\em NOT} possible when the number of channels set by the user is greater than that supported by the device.

It should be noted that the capabilities reported by a device driver or underlying audio API are not always accurate and/or may be dependent on a combination of device settings.

\section{Device Settings}\label{settings}


The next step in using {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} is to open a stream with a particular set of device settings.

\footnotesize\begin{verbatim}#include "RtAudio.h"

int main()
{
  int channels = 2;
  int sample_rate = 44100;
  int buffer_size = 256;  // 256 sample frames
  int n_buffers = 4;      // number of internal buffers used by device
  int device = 0;         // 0 indicates the default or first available device
  int stream;             // our stream identifier
  RtAudio *audio;

  // Instantiate RtAudio and open a stream within a try/catch block
  try {
    audio = new RtAudio();
    stream = audio->openStream(device, channels, 0, 0, RtAudio::RTAUDIO_FLOAT32,
                               sample_rate, &buffer_size, n_buffers);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    exit(EXIT_FAILURE);
  }

  // Clean up
  delete audio;

  return 0;
}\end{verbatim}\normalsize 


The {\bf Rt\-Audio::open\-Stream}() {\rm (p.\,\pageref{classRtAudio_a3})} method attempts to open a stream with a specified set of parameter values. When successful, a stream identifier is returned. In this case, we attempt to open a playback stream on device 0 with two channels, 32-bit floating point data, a sample rate of 44100 Hz, a frame rate of 256 sample frames per read/write, and 4 internal device buffers. When device = 0, {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} first attempts to open the default audio device with the given parameters. If that attempt fails, an attempt is made to find a device or set of devices which will meet the given parameters. If all attempts are unsuccessful, an {\bf Rt\-Audio\-Error} {\rm (p.\,\pageref{classRtAudioError})} is thrown. When a non-zero device value is specified, an attempt is made to open that device only.

{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} provides four signed integer and two floating point data formats which can be specified using the {\bf Rt\-Audio::RTAUDIO\_\-FORMAT} {\rm (p.\,\pageref{classRtAudio_s0})} parameter values mentioned earlier. If the opened device does not natively support the given format, {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} will automatically perform the necessary data format conversion.

Buffer sizes in {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} are {\em ALWAYS} given in sample frame units. For example, if you open an output stream with 4 channels and set {\em buffer\-Size} to 512, you will have to write 2048 samples of data to the output buffer within your callback or between calls to {\bf Rt\-Audio::tick\-Stream}() {\rm (p.\,\pageref{classRtAudio_a9})}. In this case, a single sample frame of data contains 4 samples of data.

The {\em buffer\-Size} parameter specifies the desired number of sample frames which will be written to and/or read from a device per write/read operation. The {\em n\-Buffers} parameter is used in setting the underlying device buffer parameters. Both the {\em buffer\-Size} and {\em n\-Buffers} parameters can be used to control stream latency though there is no guarantee that the passed values will be those used by a device. In general, lower values for both parameters will produce less latency but perhaps less robust performance. Both parameters can be specified with values of zero, in which case the smallest allowable values will be used. The {\em buffer\-Size} parameter is passed as a pointer and the actual value used by the stream is set during the device setup procedure. {\em buffer\-Size} values should be a power of two. Optimal and allowable buffer values tend to vary between systems and devices. Check the {\bf OS Notes} {\rm (p.\,\pageref{osnotes})} section for general guidelines.

As noted earlier, the device capabilities reported by a driver or underlying audio API are not always accurate and/or may be dependent on a combination of device settings. Because of this, {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} does not attempt to query a device's capabilities or use previously reported values when opening a device. Instead, {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} simply attempts to set the given parameters on a specified device and then checks whether the setup is successful or not.

\section{Playback (blocking functionality)}\label{playbackb}


Once the device is open for playback, there are only a few final steps necessary for realtime audio output. We'll first provide an example (blocking functionality) and then discuss the details.

\footnotesize\begin{verbatim}// playback.cpp

#include "RtAudio.h"

int main()
{
  int count;
  int channels = 2;
  int sample_rate = 44100;
  int buffer_size = 256;  // 256 sample frames
  int n_buffers = 4;      // number of internal buffers used by device
  float *buffer;
  int device = 0;         // 0 indicates the default or first available device
  int stream;             // our stream identifier
  RtAudio *audio;

  // Open a stream during RtAudio instantiation
  try {
    audio = new RtAudio(&stream, device, channels, 0, 0, RtAudio::RTAUDIO_FLOAT32,
                        sample_rate, &buffer_size, n_buffers);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    exit(EXIT_FAILURE);
  }

  try {
    // Get a pointer to the stream buffer
    buffer = (float *) audio->getStreamBuffer(stream);

    // Start the stream
    audio->startStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    goto cleanup;
  }

  // An example loop which runs for about 40000 sample frames
  count = 0;
  while (count < 40000) {
    // Generate your samples and fill the buffer with buffer_size sample frames of data
    ...

    // Trigger the output of the data buffer
    try {
      audio->tickStream(stream);
    }
    catch (RtAudioError &error) {
      error.printMessage();
      goto cleanup;
    }

    count += buffer_size;
  }

  try {
    // Stop and close the stream
    audio->stopStream(stream);
    audio->closeStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
  }

 cleanup:
  delete audio;

  return 0;
}\end{verbatim}\normalsize 


The first thing to notice in this example is that we attempt to open a stream during class instantiation with an overloaded constructor. This constructor simply combines the functionality of the default constructor, used earlier, and the {\bf Rt\-Audio::open\-Stream}() {\rm (p.\,\pageref{classRtAudio_a3})} method. Again, we have specified a device value of 0, indicating that the default or first available device meeting the given parameters should be used. The integer identifier of the opened stream is returned via the {\em stream} pointer value. An attempt is made to open the stream with the specified {\em buffer\-Size} value. However, it is possible that the device will not accept this value, in which case the closest allowable size is used and returned via the pointer value. The constructor can fail if no available devices are found, or a memory allocation or device driver error occurs. Note that you should not call the {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} destructor if an exception is thrown during instantiation.

Because {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} can be used to simultaneously control more than a single stream, it is necessary that the stream identifier be provided to nearly all public methods. Assuming the constructor is successful, it is necessary to get a pointer to the buffer, provided by {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})}, for use in feeding data to/from the opened stream. Note that the user should {\em NOT} attempt to deallocate the stream buffer memory ... memory management for the stream buffer will be automatically controlled by {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})}. After starting the stream with {\bf Rt\-Audio::start\-Stream}() {\rm (p.\,\pageref{classRtAudio_a11})}, one simply fills that buffer, which is of length equal to the returned {\em buffer\-Size} value, with interleaved audio data (in the specified format) for playback. Finally, a call to the {\bf Rt\-Audio::tick\-Stream}() {\rm (p.\,\pageref{classRtAudio_a9})} routine triggers a blocking write call for the stream.

In general, one should call the {\bf Rt\-Audio::stop\-Stream}() {\rm (p.\,\pageref{classRtAudio_a12})} and {\bf Rt\-Audio::close\-Stream}() {\rm (p.\,\pageref{classRtAudio_a10})} methods after finishing with a stream. However, both methods will implicitly be called during object destruction if necessary.

\section{Playback (callback functionality)}\label{playbackc}


The primary difference in using {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} with callback functionality involves the creation of a user-defined callback function. Here is an example which produces a sawtooth waveform for playback.

\footnotesize\begin{verbatim}#include <iostream.h>
#include "RtAudio.h"

// Two-channel sawtooth wave generator.
int sawtooth(char *buffer, int buffer_size, void *data)
{
  int i, j;
  double *my_buffer = (double *) buffer;
  double *my_data = (double *) data;

  // Write interleaved audio data.
  for (i=0; i<buffer_size; i++) {
    for (j=0; j<2; j++) {
      *my_buffer++ = my_data[j];

      my_data[j] += 0.005 * (j+1+(j*0.1));
      if (my_data[j] >= 1.0) my_data[j] -= 2.0;
    }
  }

  return 0;
}

int main()
{
  int channels = 2;
  int sample_rate = 44100;
  int buffer_size = 256;  // 256 sample frames
  int n_buffers = 4;      // number of internal buffers used by device
  int device = 0;         // 0 indicates the default or first available device
  int stream;             // our stream identifier
  double data[2];
  char input;
  RtAudio *audio;

  // Open a stream during RtAudio instantiation
  try {
    audio = new RtAudio(&stream, device, channels, 0, 0, RtAudio::RTAUDIO_FLOAT64,
                        sample_rate, &buffer_size, n_buffers);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    exit(EXIT_FAILURE);
  }

  try {
    // Set the stream callback function
    audio->setStreamCallback(stream, &sawtooth, (void *)data);

    // Start the stream
    audio->startStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    goto cleanup;
  }

  cout << "\nPlaying ... press <enter> to quit.\n";
  cin.get(input);

  try {
    // Stop and close the stream
    audio->stopStream(stream);
    audio->closeStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
  }

 cleanup:
  delete audio;

  return 0;
}\end{verbatim}\normalsize 


After opening the device in exactly the same way as the previous example (except with a data format change), we must set our callback function for the stream using {\bf Rt\-Audio::set\-Stream\-Callback}() {\rm (p.\,\pageref{classRtAudio_a4})}. This method will spawn a new process (or thread) which automatically calls the callback function when more data is needed. Note that the callback function is called only when the stream is \char`\"{}running\char`\"{} (between calls to the {\bf Rt\-Audio::start\-Stream}() {\rm (p.\,\pageref{classRtAudio_a11})} and {\bf Rt\-Audio::stop\-Stream}() {\rm (p.\,\pageref{classRtAudio_a12})} methods). The last argument to {\bf Rt\-Audio::set\-Stream\-Callback}() {\rm (p.\,\pageref{classRtAudio_a4})} is a pointer to arbitrary data that you wish to access from within your callback function.

In this example, we stop the stream with an explicit call to {\bf Rt\-Audio::stop\-Stream}() {\rm (p.\,\pageref{classRtAudio_a12})}. When using callback functionality, it is also possible to stop a stream by returning a non-zero value from the callback function.

Once set with {\bf Rt\-Audio::set\-Stream\-Callback} {\rm (p.\,\pageref{classRtAudio_a4})}, the callback process will continue to run for the life of the stream (until the stream is closed with {\bf Rt\-Audio::close\-Stream}() {\rm (p.\,\pageref{classRtAudio_a10})} or the {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} instance is deleted). It is possible to disassociate a callback function and cancel its process for an open stream using the {\bf Rt\-Audio::cancel\-Stream\-Callback}() {\rm (p.\,\pageref{classRtAudio_a5})} method. The stream can then be used with blocking functionality or a new callback can be associated with it.

\section{Recording}\label{recording}


Using {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} for audio input is almost identical to the way it is used for playback. Here's the blocking playback example rewritten for recording:

\footnotesize\begin{verbatim}// record.cpp

#include "RtAudio.h"

int main()
{
  int count;
  int channels = 2;
  int sample_rate = 44100;
  int buffer_size = 256;  // 256 sample frames
  int n_buffers = 4;      // number of internal buffers used by device
  float *buffer;
  int device = 0;         // 0 indicates the default or first available device
  int stream;             // our stream identifier
  RtAudio *audio;

  // Instantiate RtAudio and open a stream.
  try {
    audio = new RtAudio(&stream, 0, 0, device, channels,
                        RtAudio::RTAUDIO_FLOAT32, sample_rate, &buffer_size, n_buffers);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    exit(EXIT_FAILURE);
  }

  try {
    // Get a pointer to the stream buffer
    buffer = (float *) audio->getStreamBuffer(stream);

    // Start the stream
    audio->startStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    goto cleanup;
  }

  // An example loop which runs for about 40000 sample frames
  count = 0;
  while (count < 40000) {

    // Read a buffer of data
    try {
      audio->tickStream(stream);
    }
    catch (RtAudioError &error) {
      error.printMessage();
      goto cleanup;
    }

    // Process the input samples (buffer_size sample frames) that were read
    ...

    count += buffer_size;
  }

  try {
    // Stop the stream
    audio->stopStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
  }

 cleanup:
  delete audio;

  return 0;
}\end{verbatim}\normalsize 


In this example, the stream was opened for recording with a non-zero {\em input\-Channels} value. The only other difference between this example and that for playback involves the order of data processing in the loop, where it is necessary to first read a buffer of input data before manipulating it.

\section{Duplex Mode}\label{duplex}


Finally, it is easy to use {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} for simultaneous audio input/output, or duplex operation. In this example, we use a callback function and pass our recorded data directly through for playback.

\footnotesize\begin{verbatim}// duplex.cpp

#include <iostream.h>
#include "RtAudio.h"

// Pass-through function.
int pass(char *buffer, int buffer_size, void *)
{
  // Surprise!!  We do nothing to pass the data through.
  return 0;
}

int main()
{
  int channels = 2;
  int sample_rate = 44100;
  int buffer_size = 256;  // 256 sample frames
  int n_buffers = 4;      // number of internal buffers used by device
  int device = 0;         // 0 indicates the default or first available device
  int stream;             // our stream identifier
  double data[2];
  char input;
  RtAudio *audio;

  // Open a stream during RtAudio instantiation
  try {
    audio = new RtAudio(&stream, device, channels, device, channels, RtAudio::RTAUDIO_FLOAT64,
                        sample_rate, &buffer_size, n_buffers);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    exit(EXIT_FAILURE);
  }

  try {
    // Set the stream callback function
    audio->setStreamCallback(stream, &pass, NULL);

    // Start the stream
    audio->startStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
    goto cleanup;
  }

  cout << "\nRunning duplex ... press <enter> to quit.\n";
  cin.get(input);

  try {
    // Stop and close the stream
    audio->stopStream(stream);
    audio->closeStream(stream);
  }
  catch (RtAudioError &error) {
    error.printMessage();
  }

 cleanup:
  delete audio;

  return 0;
}\end{verbatim}\normalsize 


When an {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} stream is running in duplex mode (nonzero input {\em AND} output channels), the audio write (playback) operation always occurs before the audio read (record) operation. This sequence allows the use of a single buffer to store both output and input data.

As we see with this example, the write-read sequence of operations does not preclude the use of {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} in situations where input data is first processed and then output through a duplex stream. When the stream buffer is first allocated, it is initialized with zeros, which produces no audible result when output to the device. In this example, anything recorded by the audio stream input will be played out during the next round of audio processing.

Note that duplex operation can also be achieved by opening one output stream and one input stream using the same or different devices. However, there may be timing problems when attempting to use two different devices, due to possible device clock variations. This becomes even more difficult to achieve using two separate callback streams because it is not possible to explicitly control the calling order of the callback functions.

\section{Summary of Methods}\label{methods}


The following is short summary of public methods (not including constructors and the destructor) provided by {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})}:

\begin{CompactItemize}
 \item 
{\bf Rt\-Audio::open\-Stream}() {\rm (p.\,\pageref{classRtAudio_a3})}: opens a stream with the specified parameters. \item 
{\bf Rt\-Audio::set\-Stream\-Callback}() {\rm (p.\,\pageref{classRtAudio_a4})}: sets a user-defined callback function for a given stream. \item 
{\bf Rt\-Audio::cancel\-Stream\-Callback}() {\rm (p.\,\pageref{classRtAudio_a5})}: cancels a callback process and function for a given stream. \item 
{\bf Rt\-Audio::get\-Device\-Count}() {\rm (p.\,\pageref{classRtAudio_a6})}: returns the number of audio devices available. \item 
{\bf Rt\-Audio::get\-Device\-Info}() {\rm (p.\,\pageref{classRtAudio_a7})}: fills a user-supplied RTAUDIO\_\-DEVICE structure for a specified device. \item 
{\bf Rt\-Audio::get\-Stream\-Buffer}() {\rm (p.\,\pageref{classRtAudio_a8})}: returns a pointer to the stream buffer. \item 
{\bf Rt\-Audio::tick\-Stream}() {\rm (p.\,\pageref{classRtAudio_a9})}: triggers processing of input/output data for a stream (blocking). \item 
{\bf Rt\-Audio::close\-Stream}() {\rm (p.\,\pageref{classRtAudio_a10})}: closes the specified stream (implicitly called during object destruction). Once a stream is closed, the stream identifier is invalid and should not be used in calling any other {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} methods. \item 
{\bf Rt\-Audio::start\-Stream}() {\rm (p.\,\pageref{classRtAudio_a11})}: (re)starts the specified stream, typically after it has been stopped with either stop\-Stream() or abort\-Stream() or after first opening the stream. \item 
{\bf Rt\-Audio::stop\-Stream}() {\rm (p.\,\pageref{classRtAudio_a12})}: stops the specified stream, allowing any remaining samples in the queue to be played out and/or read in. This does not implicitly call {\bf Rt\-Audio::close\-Stream}() {\rm (p.\,\pageref{classRtAudio_a10})}. \item 
{\bf Rt\-Audio::abort\-Stream}() {\rm (p.\,\pageref{classRtAudio_a13})}: stops the specified stream, discarding any remaining samples in the queue. This does not implicitly call close\-Stream(). \item 
{\bf Rt\-Audio::stream\-Will\-Block}() {\rm (p.\,\pageref{classRtAudio_a14})}: queries a stream to determine whether a call to the {\em tick\-Stream()} method will block. A return value of 0 indicates that the stream will NOT block. A positive return value indicates the number of sample frames that cannot yet be processed without blocking. \end{CompactItemize}


\section{Compiling}\label{compiling}


In order to compile {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} for a specific OS and audio API, it is necessary to supply the appropriate preprocessor definition and library within the compiler statement: 



  \begin{TabularC}{5}
\hline
{\bf OS:} &{\bf Audio API:} &{\bf Preprocessor Definition:} &{\bf Library:} &{\bf Example Compiler Statement:}   \\\hline
Linux &ALSA &\_\-\_\-LINUX\_\-ALSA\_\- &{\tt libasound, libpthread} &{\tt g++ -Wall -D\_\-\_\-LINUX\_\-ALSA\_\- -o probe probe.cpp Rt\-Audio.cpp -lasound -lpthread}   \\\hline
Linux &OSS &\_\-\_\-LINUX\_\-OSS\_\- &{\tt libpthread} &{\tt g++ -Wall -D\_\-\_\-LINUX\_\-OSS\_\- -o probe probe.cpp Rt\-Audio.cpp -lpthread}   \\\hline
Irix &AL &\_\-\_\-IRIX\_\-AL\_\- &{\tt libaudio, libpthread} &{\tt CC -Wall -D\_\-\_\-IRIX\_\-AL\_\- -o probe probe.cpp Rt\-Audio.cpp -laudio -lpthread}   \\\hline
Windows &Direct Sound &\_\-\_\-WINDOWS\_\-DS\_\- &{\tt dsound.lib (ver. 5.0 or higher), multithreaded} &{\em compiler specific}  \\\hline
\end{TabularC}
 



The example compiler statements above could be used to compile the {\tt probe.cpp} example file, assuming that {\tt probe.cpp}, {\tt {\bf Rt\-Audio.h}}, and {\tt Rt\-Audio.cpp} all exist in the same directory.

\section{OS Notes}\label{osnotes}


{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} is designed to provide a common API across the various supported operating systems and audio libraries. Despite that, however, some issues need to be mentioned with regard to each.

\subsection{Linux:}\label{linux}


{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} for Linux was developed under Redhat distributions 7.0 - 7.2. Two different audio APIs are supported on Linux platforms: OSS and {\tt ALSA}. The OSS API has existed for at least 6 years and the Linux kernel is distributed with free versions of OSS audio drivers. Therefore, a generic Linux system is most likely to have OSS support. The ALSA API is relatively new and at this time is not part of the Linux kernel distribution. Work is in progress to make ALSA part of the 2.5 development kernel series. Despite that, the ALSA API offers significantly better functionality than the OSS API. {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} provides support for the 0.9 and higher versions of ALSA. Input/output latency on the order of 15-20 milliseconds can typically be achieved under both OSS or ALSA by fine-tuning the {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} buffer parameters (without kernel modifications). Latencies on the order of 5 milliseconds or less can be achieved using a low-latency kernel patch and increasing FIFO scheduling priority. The pthread library, which is used for callback functionality, is a standard component of all Linux distributions.

The ALSA library includes OSS emulation support. That means that you can run programs compiled for the OSS API even when using the ALSA drivers and library. It should be noted however that OSS emulation under ALSA is not perfect. Specifically, channel number queries seem to consistently produce invalid results. While OSS emulation is successful for the majority of {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} tests, it is recommended that the native ALSA implementation of {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} be used on systems which have ALSA drivers installed.

The ALSA implementation of {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} makes no use of the ALSA \char`\"{}plug\char`\"{} interface. All necessary data format conversions, channel compensation, deinterleaving, and byte-swapping is handled by internal {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} routines.

\subsection{Irix (SGI):}\label{irix}


The Irix version of {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} was written and tested on an SGI Indy running Irix version 6.5 and the newer \char`\"{}al\char`\"{} audio library. {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} does not compile under Irix version 6.3 because the C++ compiler is too old. Despite the relatively slow speed of the Indy, {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} was found to behave quite well and input/output latency was very good. No problems were found with respect to using the pthread library.

\subsection{Windows:}\label{windows}


{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} under Windows is written using the Direct\-Sound API. In order to compile {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} under Windows, you must have the header and source files for Direct\-Sound version 0.5 or higher. As far as I know, you cannot compile {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} for Windows NT because there is not sufficient Direct\-Sound support. Audio output latency with Direct\-Sound can be reasonably good (on the order of 20 milliseconds). On the other hand, input audio latency tends to be terrible (100 milliseconds or more). Further, Direct\-Sound drivers tend to crash easily when experimenting with buffer parameters. On my system, I found it necessary to use values around n\-Buffers = 8 and buffer\-Size = 512 to avoid crashing my system. {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} was developed with Visual C++ version 6.0. I was forced in several instances to modify code in order to get it to compile under the non-standard version of C++ that Microsoft so unprofessionally implemented. We can only hope that the developers of Visual C++ 7.0 will have time to read the C++ standard.

\section{Acknowledgments}\label{acknowledge}


The {\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} API incorporates many of the concepts developed in the {\tt Port\-Audio} project by Phil Burk and Ross Bencina. Early development also incorporated ideas from Bill Schottstaedt's {\tt sndlib}. The CCRMA {\tt Sound\-Wire group} provided valuable feedback during the API proposal stages.

{\bf Rt\-Audio} {\rm (p.\,\pageref{classRtAudio})} was slowly developed over the course of many months while in residence at the {\tt Institut Universitari de L'Audiovisual (IUA)} in Barcelona, Spain, the {\tt Laboratory of Acoustics and Audio Signal Processing} at the Helsinki University of Technology, Finland, and the {\tt Center for Computer Research in Music and Acoustics (CCRMA)} at {\tt Stanford University}. This work was supported in part by the United States Air Force Office of Scientific Research (grant \#F49620-99-1-0293).

These documentation files were generated using {\tt doxygen} by Dimitri van Heesch.

